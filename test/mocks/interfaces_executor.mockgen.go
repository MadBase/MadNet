// Code generated by go-mockgen 1.1.4; DO NOT EDIT.

package mocks

import (
	"context"
	"sync"

	ethereum "github.com/MadBase/MadNet/blockchain/ethereum"
	interfaces "github.com/MadBase/MadNet/blockchain/executor/interfaces"
	logrus "github.com/sirupsen/logrus"
)

// MockITask is a mock implementation of the ITask interface (from the
// package github.com/MadBase/MadNet/blockchain/executor/interfaces) used
// for unit testing.
type MockITask struct {
	// DoDoneFunc is an instance of a mock function object controlling the
	// behavior of the method DoDone.
	DoDoneFunc *ITaskDoDoneFunc
	// DoRetryFunc is an instance of a mock function object controlling the
	// behavior of the method DoRetry.
	DoRetryFunc *ITaskDoRetryFunc
	// DoWorkFunc is an instance of a mock function object controlling the
	// behavior of the method DoWork.
	DoWorkFunc *ITaskDoWorkFunc
	// GetExecutionDataFunc is an instance of a mock function object
	// controlling the behavior of the method GetExecutionData.
	GetExecutionDataFunc *ITaskGetExecutionDataFunc
	// InitializeFunc is an instance of a mock function object controlling
	// the behavior of the method Initialize.
	InitializeFunc *ITaskInitializeFunc
	// ShouldRetryFunc is an instance of a mock function object controlling
	// the behavior of the method ShouldRetry.
	ShouldRetryFunc *ITaskShouldRetryFunc
}

// NewMockITask creates a new mock of the ITask interface. All methods
// return zero values for all results, unless overwritten.
func NewMockITask() *MockITask {
	return &MockITask{
		DoDoneFunc: &ITaskDoDoneFunc{
			defaultHook: func(*logrus.Entry) {
				return
			},
		},
		DoRetryFunc: &ITaskDoRetryFunc{
			defaultHook: func(context.Context, *logrus.Entry, ethereum.Network) error {
				return nil
			},
		},
		DoWorkFunc: &ITaskDoWorkFunc{
			defaultHook: func(context.Context, *logrus.Entry, ethereum.Network) error {
				return nil
			},
		},
		GetExecutionDataFunc: &ITaskGetExecutionDataFunc{
			defaultHook: func() interfaces.ITaskExecutionData {
				return nil
			},
		},
		InitializeFunc: &ITaskInitializeFunc{
			defaultHook: func(context.Context, *logrus.Entry, ethereum.Network) error {
				return nil
			},
		},
		ShouldRetryFunc: &ITaskShouldRetryFunc{
			defaultHook: func(context.Context, *logrus.Entry, ethereum.Network) bool {
				return false
			},
		},
	}
}

// NewStrictMockITask creates a new mock of the ITask interface. All methods
// panic on invocation, unless overwritten.
func NewStrictMockITask() *MockITask {
	return &MockITask{
		DoDoneFunc: &ITaskDoDoneFunc{
			defaultHook: func(*logrus.Entry) {
				panic("unexpected invocation of MockITask.DoDone")
			},
		},
		DoRetryFunc: &ITaskDoRetryFunc{
			defaultHook: func(context.Context, *logrus.Entry, ethereum.Network) error {
				panic("unexpected invocation of MockITask.DoRetry")
			},
		},
		DoWorkFunc: &ITaskDoWorkFunc{
			defaultHook: func(context.Context, *logrus.Entry, ethereum.Network) error {
				panic("unexpected invocation of MockITask.DoWork")
			},
		},
		GetExecutionDataFunc: &ITaskGetExecutionDataFunc{
			defaultHook: func() interfaces.ITaskExecutionData {
				panic("unexpected invocation of MockITask.GetExecutionData")
			},
		},
		InitializeFunc: &ITaskInitializeFunc{
			defaultHook: func(context.Context, *logrus.Entry, ethereum.Network) error {
				panic("unexpected invocation of MockITask.Initialize")
			},
		},
		ShouldRetryFunc: &ITaskShouldRetryFunc{
			defaultHook: func(context.Context, *logrus.Entry, ethereum.Network) bool {
				panic("unexpected invocation of MockITask.ShouldRetry")
			},
		},
	}
}

// NewMockITaskFrom creates a new mock of the MockITask interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockITaskFrom(i interfaces.ITask) *MockITask {
	return &MockITask{
		DoDoneFunc: &ITaskDoDoneFunc{
			defaultHook: i.DoDone,
		},
		DoRetryFunc: &ITaskDoRetryFunc{
			defaultHook: i.DoRetry,
		},
		DoWorkFunc: &ITaskDoWorkFunc{
			defaultHook: i.DoWork,
		},
		GetExecutionDataFunc: &ITaskGetExecutionDataFunc{
			defaultHook: i.GetExecutionData,
		},
		InitializeFunc: &ITaskInitializeFunc{
			defaultHook: i.Initialize,
		},
		ShouldRetryFunc: &ITaskShouldRetryFunc{
			defaultHook: i.ShouldRetry,
		},
	}
}

// ITaskDoDoneFunc describes the behavior when the DoDone method of the
// parent MockITask instance is invoked.
type ITaskDoDoneFunc struct {
	defaultHook func(*logrus.Entry)
	hooks       []func(*logrus.Entry)
	history     []ITaskDoDoneFuncCall
	mutex       sync.Mutex
}

// DoDone delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockITask) DoDone(v0 *logrus.Entry) {
	m.DoDoneFunc.nextHook()(v0)
	m.DoDoneFunc.appendCall(ITaskDoDoneFuncCall{v0})
	return
}

// SetDefaultHook sets function that is called when the DoDone method of the
// parent MockITask instance is invoked and the hook queue is empty.
func (f *ITaskDoDoneFunc) SetDefaultHook(hook func(*logrus.Entry)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DoDone method of the parent MockITask instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *ITaskDoDoneFunc) PushHook(hook func(*logrus.Entry)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ITaskDoDoneFunc) SetDefaultReturn() {
	f.SetDefaultHook(func(*logrus.Entry) {
		return
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ITaskDoDoneFunc) PushReturn() {
	f.PushHook(func(*logrus.Entry) {
		return
	})
}

func (f *ITaskDoDoneFunc) nextHook() func(*logrus.Entry) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ITaskDoDoneFunc) appendCall(r0 ITaskDoDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ITaskDoDoneFuncCall objects describing the
// invocations of this function.
func (f *ITaskDoDoneFunc) History() []ITaskDoDoneFuncCall {
	f.mutex.Lock()
	history := make([]ITaskDoDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ITaskDoDoneFuncCall is an object that describes an invocation of method
// DoDone on an instance of MockITask.
type ITaskDoDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 *logrus.Entry
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ITaskDoDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ITaskDoDoneFuncCall) Results() []interface{} {
	return []interface{}{}
}

// ITaskDoRetryFunc describes the behavior when the DoRetry method of the
// parent MockITask instance is invoked.
type ITaskDoRetryFunc struct {
	defaultHook func(context.Context, *logrus.Entry, ethereum.Network) error
	hooks       []func(context.Context, *logrus.Entry, ethereum.Network) error
	history     []ITaskDoRetryFuncCall
	mutex       sync.Mutex
}

// DoRetry delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockITask) DoRetry(v0 context.Context, v1 *logrus.Entry, v2 ethereum.Network) error {
	r0 := m.DoRetryFunc.nextHook()(v0, v1, v2)
	m.DoRetryFunc.appendCall(ITaskDoRetryFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the DoRetry method of
// the parent MockITask instance is invoked and the hook queue is empty.
func (f *ITaskDoRetryFunc) SetDefaultHook(hook func(context.Context, *logrus.Entry, ethereum.Network) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DoRetry method of the parent MockITask instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *ITaskDoRetryFunc) PushHook(hook func(context.Context, *logrus.Entry, ethereum.Network) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ITaskDoRetryFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, *logrus.Entry, ethereum.Network) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ITaskDoRetryFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, *logrus.Entry, ethereum.Network) error {
		return r0
	})
}

func (f *ITaskDoRetryFunc) nextHook() func(context.Context, *logrus.Entry, ethereum.Network) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ITaskDoRetryFunc) appendCall(r0 ITaskDoRetryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ITaskDoRetryFuncCall objects describing the
// invocations of this function.
func (f *ITaskDoRetryFunc) History() []ITaskDoRetryFuncCall {
	f.mutex.Lock()
	history := make([]ITaskDoRetryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ITaskDoRetryFuncCall is an object that describes an invocation of method
// DoRetry on an instance of MockITask.
type ITaskDoRetryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 *logrus.Entry
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 ethereum.Network
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ITaskDoRetryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ITaskDoRetryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ITaskDoWorkFunc describes the behavior when the DoWork method of the
// parent MockITask instance is invoked.
type ITaskDoWorkFunc struct {
	defaultHook func(context.Context, *logrus.Entry, ethereum.Network) error
	hooks       []func(context.Context, *logrus.Entry, ethereum.Network) error
	history     []ITaskDoWorkFuncCall
	mutex       sync.Mutex
}

// DoWork delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockITask) DoWork(v0 context.Context, v1 *logrus.Entry, v2 ethereum.Network) error {
	r0 := m.DoWorkFunc.nextHook()(v0, v1, v2)
	m.DoWorkFunc.appendCall(ITaskDoWorkFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the DoWork method of the
// parent MockITask instance is invoked and the hook queue is empty.
func (f *ITaskDoWorkFunc) SetDefaultHook(hook func(context.Context, *logrus.Entry, ethereum.Network) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DoWork method of the parent MockITask instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *ITaskDoWorkFunc) PushHook(hook func(context.Context, *logrus.Entry, ethereum.Network) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ITaskDoWorkFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, *logrus.Entry, ethereum.Network) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ITaskDoWorkFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, *logrus.Entry, ethereum.Network) error {
		return r0
	})
}

func (f *ITaskDoWorkFunc) nextHook() func(context.Context, *logrus.Entry, ethereum.Network) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ITaskDoWorkFunc) appendCall(r0 ITaskDoWorkFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ITaskDoWorkFuncCall objects describing the
// invocations of this function.
func (f *ITaskDoWorkFunc) History() []ITaskDoWorkFuncCall {
	f.mutex.Lock()
	history := make([]ITaskDoWorkFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ITaskDoWorkFuncCall is an object that describes an invocation of method
// DoWork on an instance of MockITask.
type ITaskDoWorkFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 *logrus.Entry
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 ethereum.Network
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ITaskDoWorkFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ITaskDoWorkFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ITaskGetExecutionDataFunc describes the behavior when the
// GetExecutionData method of the parent MockITask instance is invoked.
type ITaskGetExecutionDataFunc struct {
	defaultHook func() interfaces.ITaskExecutionData
	hooks       []func() interfaces.ITaskExecutionData
	history     []ITaskGetExecutionDataFuncCall
	mutex       sync.Mutex
}

// GetExecutionData delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockITask) GetExecutionData() interfaces.ITaskExecutionData {
	r0 := m.GetExecutionDataFunc.nextHook()()
	m.GetExecutionDataFunc.appendCall(ITaskGetExecutionDataFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the GetExecutionData
// method of the parent MockITask instance is invoked and the hook queue is
// empty.
func (f *ITaskGetExecutionDataFunc) SetDefaultHook(hook func() interfaces.ITaskExecutionData) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetExecutionData method of the parent MockITask instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *ITaskGetExecutionDataFunc) PushHook(hook func() interfaces.ITaskExecutionData) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ITaskGetExecutionDataFunc) SetDefaultReturn(r0 interfaces.ITaskExecutionData) {
	f.SetDefaultHook(func() interfaces.ITaskExecutionData {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ITaskGetExecutionDataFunc) PushReturn(r0 interfaces.ITaskExecutionData) {
	f.PushHook(func() interfaces.ITaskExecutionData {
		return r0
	})
}

func (f *ITaskGetExecutionDataFunc) nextHook() func() interfaces.ITaskExecutionData {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ITaskGetExecutionDataFunc) appendCall(r0 ITaskGetExecutionDataFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ITaskGetExecutionDataFuncCall objects
// describing the invocations of this function.
func (f *ITaskGetExecutionDataFunc) History() []ITaskGetExecutionDataFuncCall {
	f.mutex.Lock()
	history := make([]ITaskGetExecutionDataFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ITaskGetExecutionDataFuncCall is an object that describes an invocation
// of method GetExecutionData on an instance of MockITask.
type ITaskGetExecutionDataFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 interfaces.ITaskExecutionData
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ITaskGetExecutionDataFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ITaskGetExecutionDataFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ITaskInitializeFunc describes the behavior when the Initialize method of
// the parent MockITask instance is invoked.
type ITaskInitializeFunc struct {
	defaultHook func(context.Context, *logrus.Entry, ethereum.Network) error
	hooks       []func(context.Context, *logrus.Entry, ethereum.Network) error
	history     []ITaskInitializeFuncCall
	mutex       sync.Mutex
}

// Initialize delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockITask) Initialize(v0 context.Context, v1 *logrus.Entry, v2 ethereum.Network) error {
	r0 := m.InitializeFunc.nextHook()(v0, v1, v2)
	m.InitializeFunc.appendCall(ITaskInitializeFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Initialize method of
// the parent MockITask instance is invoked and the hook queue is empty.
func (f *ITaskInitializeFunc) SetDefaultHook(hook func(context.Context, *logrus.Entry, ethereum.Network) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Initialize method of the parent MockITask instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *ITaskInitializeFunc) PushHook(hook func(context.Context, *logrus.Entry, ethereum.Network) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ITaskInitializeFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, *logrus.Entry, ethereum.Network) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ITaskInitializeFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, *logrus.Entry, ethereum.Network) error {
		return r0
	})
}

func (f *ITaskInitializeFunc) nextHook() func(context.Context, *logrus.Entry, ethereum.Network) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ITaskInitializeFunc) appendCall(r0 ITaskInitializeFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ITaskInitializeFuncCall objects describing
// the invocations of this function.
func (f *ITaskInitializeFunc) History() []ITaskInitializeFuncCall {
	f.mutex.Lock()
	history := make([]ITaskInitializeFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ITaskInitializeFuncCall is an object that describes an invocation of
// method Initialize on an instance of MockITask.
type ITaskInitializeFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 *logrus.Entry
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 ethereum.Network
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ITaskInitializeFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ITaskInitializeFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// ITaskShouldRetryFunc describes the behavior when the ShouldRetry method
// of the parent MockITask instance is invoked.
type ITaskShouldRetryFunc struct {
	defaultHook func(context.Context, *logrus.Entry, ethereum.Network) bool
	hooks       []func(context.Context, *logrus.Entry, ethereum.Network) bool
	history     []ITaskShouldRetryFuncCall
	mutex       sync.Mutex
}

// ShouldRetry delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockITask) ShouldRetry(v0 context.Context, v1 *logrus.Entry, v2 ethereum.Network) bool {
	r0 := m.ShouldRetryFunc.nextHook()(v0, v1, v2)
	m.ShouldRetryFunc.appendCall(ITaskShouldRetryFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the ShouldRetry method
// of the parent MockITask instance is invoked and the hook queue is empty.
func (f *ITaskShouldRetryFunc) SetDefaultHook(hook func(context.Context, *logrus.Entry, ethereum.Network) bool) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ShouldRetry method of the parent MockITask instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *ITaskShouldRetryFunc) PushHook(hook func(context.Context, *logrus.Entry, ethereum.Network) bool) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ITaskShouldRetryFunc) SetDefaultReturn(r0 bool) {
	f.SetDefaultHook(func(context.Context, *logrus.Entry, ethereum.Network) bool {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ITaskShouldRetryFunc) PushReturn(r0 bool) {
	f.PushHook(func(context.Context, *logrus.Entry, ethereum.Network) bool {
		return r0
	})
}

func (f *ITaskShouldRetryFunc) nextHook() func(context.Context, *logrus.Entry, ethereum.Network) bool {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ITaskShouldRetryFunc) appendCall(r0 ITaskShouldRetryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ITaskShouldRetryFuncCall objects describing
// the invocations of this function.
func (f *ITaskShouldRetryFunc) History() []ITaskShouldRetryFuncCall {
	f.mutex.Lock()
	history := make([]ITaskShouldRetryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ITaskShouldRetryFuncCall is an object that describes an invocation of
// method ShouldRetry on an instance of MockITask.
type ITaskShouldRetryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 *logrus.Entry
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 ethereum.Network
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ITaskShouldRetryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ITaskShouldRetryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
